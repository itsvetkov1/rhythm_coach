---
phase: 02-onset-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ai_rhythm_coach/lib/services/rhythm_analyzer.dart
autonomous: true

must_haves:
  truths:
    - "FFT-based spectral flux with adaptive thresholding detects onset times corresponding to actual drum hits"
    - "Detection works for soft taps (amplitude 0.3) through loud taps (amplitude 1.0)"
    - "Detection works across BPM range 40-200 without parameter changes"
    - "Each detected onset is matched to nearest expected beat with timing error in milliseconds"
    - "MetronomeBleedException propagates instead of being swallowed by catch-all"
  artifacts:
    - path: "ai_rhythm_coach/lib/services/rhythm_analyzer.dart"
      provides: "Improved onset detection with adaptive thresholding, log compression, BPM-aware inter-onset interval, peak picking"
      contains: "_adaptiveThreshold"
      exports: ["RhythmAnalyzer", "MetronomeBleedException"]
  key_links:
    - from: "ai_rhythm_coach/lib/services/rhythm_analyzer.dart"
      to: "fftea"
      via: "Window.hanning for windowing, FFT for spectral analysis"
      pattern: "Window\\.hanning"
    - from: "_detectOnsets"
      to: "_adaptiveThreshold"
      via: "spectral flux values fed to adaptive threshold computation"
      pattern: "_adaptiveThreshold\\(fluxValues"
    - from: "_detectOnsets"
      to: "_minOnsetInterval"
      via: "BPM-aware minimum interval prevents double-triggers"
      pattern: "_minOnsetInterval\\(bpm\\)"
---

<objective>
Refactor RhythmAnalyzer._detectOnsets to use adaptive thresholding, logarithmic compression, BPM-aware inter-onset interval, and peak picking so that onset detection works reliably across the full volume and BPM range required by the app.

Purpose: The current fixed-threshold implementation (0.12) fails to detect soft taps and has no BPM awareness, making it unreliable for real-world use. The refactored algorithm must handle soft-to-loud taps at 40-200 BPM without manual threshold tuning.

Output: Improved `rhythm_analyzer.dart` with adaptive onset detection that passes all existing tests plus the currently-failing soft claps test.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-onset-detection/02-RESEARCH.md
@ai_rhythm_coach/lib/services/rhythm_analyzer.dart
@ai_rhythm_coach/lib/models/tap_event.dart
@ai_rhythm_coach/test/services/rhythm_analyzer_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor _detectOnsets with adaptive thresholding and supporting methods</name>
  <files>ai_rhythm_coach/lib/services/rhythm_analyzer.dart</files>
  <action>
Refactor the `_detectOnsets` method and add supporting helper methods. The method signature changes to accept `bpm` parameter: `List<double> _detectOnsets(List<double> samples, int bpm)`. Update the call site in `analyzeAudio` to pass `bpm`.

**Step 1: Replace hand-rolled Hanning window with fftea's Window.hanning.**
Delete the `_applyHanningWindow` method entirely. In the FFT loop, replace:
```dart
final windowedSamples = _applyHanningWindow(window);
```
with:
```dart
final hanningWindow = Window.hanning(fftSize);
final windowedSamples = hanningWindow(window);
```
Note: `Window.hanning(n)` returns a function `List<double> Function(List<double>)` that applies the window in-place. Check fftea API -- if `Window.hanning` returns a `Float64List` instead of a function, use it as a multiplier: `for (int j = 0; j < fftSize; j++) { windowedSamples[j] = window[j] * hanningWindow[j]; }`.

**Step 2: Add logarithmic compression to magnitude extraction.**
After computing raw magnitudes from the FFT complex spectrum, apply log compression:
```dart
final magnitude = sqrt(real * real + imag * imag);
rawMagnitudes.add(log(1.0 + _gamma * magnitude));
```
Add a named constant: `static const double _gamma = 10.0;` (log compression strength -- start moderate, tune on device if needed).

**Step 3: Rewrite _detectOnsets with two-pass approach.**
Pass 1: Compute all spectral flux values and frame times into lists. Use half-wave rectified flux (only positive magnitude differences, same as current code). Store `fluxValues` and `frameTimes` lists.

Pass 2: Apply adaptive thresholding and peak picking to the flux list.

The frame time calculation should use `(i + hopSize / 2) / sampleRate` instead of the current `(i + fftSize / 2) / sampleRate` because spectral flux measures change between frames, so the onset is between the current and previous frame positions.

**Step 4: Add `_adaptiveThreshold` method.**
```dart
List<double> _adaptiveThreshold(List<double> fluxValues, {
  int preAvgFrames = 10,   // ~100ms lookback at 512 hop / 44100 Hz
  int postAvgFrames = 3,   // ~30ms lookahead
  double delta = 2.0,      // multiplier above local average
  double offset = 0.01,    // minimum threshold floor
})
```
For each frame index, compute the mean of `fluxValues[max(0, i-preAvgFrames) .. min(len, i+postAvgFrames+1)]`. Threshold[i] = mean * delta + offset.

**Step 5: Add `_minOnsetInterval` method.**
```dart
double _minOnsetInterval(int bpm) {
  final beatInterval = 60.0 / bpm;
  return max(0.05, beatInterval * 0.4); // 40% of beat interval, min 50ms
}
```

**Step 6: Add `_isLocalMax` helper.**
```dart
bool _isLocalMax(List<double> flux, int index) {
  if (index <= 0 || index >= flux.length - 1) return false;
  return flux[index] > flux[index - 1] && flux[index] > flux[index + 1];
}
```

**Step 7: Peak picking loop in _detectOnsets.**
After computing fluxValues and thresholds:
```dart
final minInterval = _minOnsetInterval(bpm);
for (int i = 1; i < fluxValues.length - 1; i++) {
  if (fluxValues[i] > thresholds[i] && _isLocalMax(fluxValues, i)) {
    final time = frameTimes[i];
    if (onsets.isEmpty || (time - onsets.last) > minInterval) {
      onsets.add(time);
    }
  }
}
```

**Step 8: Fix error handling in analyzeAudio.**
The current catch block swallows all exceptions including MetronomeBleedException. Change the try/catch to:
1. Re-throw `MetronomeBleedException` (callers need to handle bleed detection).
2. For `FileSystemException` or file-not-found, return empty list (expected failure).
3. For all other unexpected exceptions, re-throw them so bugs surface during development.

Structure:
```dart
} on MetronomeBleedException {
  rethrow;
} on FileSystemException {
  print('ERROR: File system error during analysis: $e');
  return [];
} catch (e, stackTrace) {
  // Re-throw unexpected errors so they surface during development
  print('ERROR: Unexpected rhythm analysis failure: $e');
  rethrow;
}
```

**Step 9: Remove the fixed `onsetThreshold` constant.**
It is no longer used since adaptive thresholding replaces it. Remove:
```dart
static const double onsetThreshold = 0.12;
```

**Step 10: Clean up DEBUG print statements.**
Keep only the high-level summary prints (total samples, duration, RMS, onset count, match rate). Remove verbose per-frame debugging. The analyzer is a library, not a debugging tool.

**Important:** Do NOT change `_loadAudioSamples`, `_generateExpectedBeats`, `_matchOnsetsToBeats`, `_findNearestOnset`, `calculateAverageError`, `calculateMeanSignedError`, `calculateConsistency`, or the `MetronomeBleedException` class. These all work correctly. Only modify `_detectOnsets`, `analyzeAudio` (error handling + passing bpm to _detectOnsets), and add the new helper methods.
  </action>
  <verify>
Run existing tests:
```bash
cd ai_rhythm_coach && flutter test test/services/rhythm_analyzer_test.dart
```
All 9 tests should pass, including the previously-failing "Should detect soft claps" test.

Also run the latency test to verify latency compensation still works:
```bash
cd ai_rhythm_coach && flutter test test/rhythm_analyzer_latency_test.dart
```

And the diagnostic test:
```bash
cd ai_rhythm_coach && flutter test test/services/rhythm_analyzer_diagnostic_test.dart
```
  </verify>
  <done>
All existing tests pass (9/9 in rhythm_analyzer_test.dart, including soft claps). Latency tests pass. Diagnostic tests pass. The `_detectOnsets` method uses adaptive thresholding instead of fixed threshold, applies log compression, uses BPM-aware inter-onset interval, and requires local maximum for peak picking. MetronomeBleedException is re-thrown instead of swallowed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify algorithm correctness with flutter analyze</name>
  <files>ai_rhythm_coach/lib/services/rhythm_analyzer.dart</files>
  <action>
Run static analysis to confirm no type errors, unused imports, or lint warnings were introduced:
```bash
cd ai_rhythm_coach && flutter analyze lib/services/rhythm_analyzer.dart
```

If any issues are found, fix them. Common issues to watch for:
- Unused import of `dart:math` functions (log, sqrt, etc.) -- these should all still be needed
- Type mismatch between fftea's Window.hanning return type and how it's used
- The `_detectOnsets` signature change (now takes `int bpm`) must be reflected at all call sites
  </action>
  <verify>
```bash
cd ai_rhythm_coach && flutter analyze lib/services/rhythm_analyzer.dart
```
Should report "No issues found!"
  </verify>
  <done>
`flutter analyze` reports no issues for rhythm_analyzer.dart. Code compiles cleanly with all new methods and refactored _detectOnsets.
  </done>
</task>

</tasks>

<verification>
1. `flutter test test/services/rhythm_analyzer_test.dart` -- All 9 tests pass (including soft claps)
2. `flutter test test/rhythm_analyzer_latency_test.dart` -- Both latency tests pass
3. `flutter test test/services/rhythm_analyzer_diagnostic_test.dart` -- All diagnostic tests pass
4. `flutter analyze lib/services/rhythm_analyzer.dart` -- No issues found
5. The fixed `onsetThreshold = 0.12` constant is removed
6. `_applyHanningWindow` method is removed (replaced by fftea Window.hanning)
7. `_adaptiveThreshold`, `_minOnsetInterval`, `_isLocalMax` methods exist
8. `MetronomeBleedException` is re-thrown, not swallowed
</verification>

<success_criteria>
- All existing rhythm_analyzer tests pass (9/9), including the previously-failing soft claps test
- Latency compensation tests still pass (sign convention preserved)
- Diagnostic tests still pass
- Static analysis clean
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/02-onset-detection/02-01-SUMMARY.md`
</output>
