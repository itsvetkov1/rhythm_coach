---
phase: 02-onset-detection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - ai_rhythm_coach/test/services/rhythm_analyzer_test.dart
autonomous: false

must_haves:
  truths:
    - "Detection rate is >= 80% across the full BPM range (40, 60, 80, 100, 120, 140, 160, 180, 200)"
    - "Detection rate is >= 80% across amplitude range (0.1 soft, 0.3 medium-soft, 0.5 medium, 0.8 loud, 1.0 max)"
    - "Timing error for detected beats is within 50ms for synthetic test data"
    - "No double-detection (detected count <= 1.2x expected) at any BPM"
    - "Constant tone does not produce false onset detections"
  artifacts:
    - path: "ai_rhythm_coach/test/services/rhythm_analyzer_test.dart"
      provides: "Comprehensive test suite validating BPM range, amplitude range, timing accuracy, and no double-detection"
      contains: "BPM Range Detection"
  key_links:
    - from: "ai_rhythm_coach/test/services/rhythm_analyzer_test.dart"
      to: "ai_rhythm_coach/lib/services/rhythm_analyzer.dart"
      via: "RhythmAnalyzer.analyzeAudio called with synthetic WAV files at various BPMs and amplitudes"
      pattern: "analyzer\\.analyzeAudio"
---

<objective>
Expand the RhythmAnalyzer test suite to validate onset detection accuracy across the full BPM range (40-200) and amplitude range (soft to loud), proving the algorithm meets Phase 2 success criteria.

Purpose: The current test suite has a handful of point tests at specific BPMs (60, 100, 120). Phase 2 requires proof that detection works across 40-200 BPM and soft-to-loud volumes. Without these tests, we cannot claim the success criteria are met.

Output: Expanded `rhythm_analyzer_test.dart` with parameterized BPM range tests, amplitude range tests, timing accuracy assertions, and double-detection guards.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-onset-detection/02-RESEARCH.md
@.planning/phases/02-onset-detection/02-01-SUMMARY.md
@ai_rhythm_coach/lib/services/rhythm_analyzer.dart
@ai_rhythm_coach/test/services/rhythm_analyzer_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BPM range and amplitude range parameterized tests</name>
  <files>ai_rhythm_coach/test/services/rhythm_analyzer_test.dart</files>
  <action>
Add new test groups to the existing `rhythm_analyzer_test.dart` file. Do NOT remove or modify existing tests -- only add new groups after the existing "Edge Cases" group.

**First, extract the `_createWavFile` helper to a shared helper or make it top-level (it already is -- good).**

**Add a configurable `_createTestWavWithBeats` helper function** (top-level, next to existing `_createWavFile`):
```dart
Future<void> _createTestWavWithBeats(
  File file, {
  required int sampleRate,
  required int bpm,
  required int durationSeconds,
  double amplitude = 0.8,
}) async {
  final beatInterval = 60.0 / bpm;
  final samples = List<int>.filled(sampleRate * durationSeconds, 0);

  for (double beatTime = 0.0; beatTime < durationSeconds; beatTime += beatInterval) {
    final sampleIndex = (beatTime * sampleRate).round();
    // Broadband impulse with linear decay envelope (more realistic than pure sine)
    for (int i = 0; i < 200; i++) {
      if (sampleIndex + i < samples.length) {
        final envelope = 1.0 - (i / 200.0);
        final signal = amplitude * 32000 * envelope * sin(2 * pi * 800 * i / sampleRate);
        samples[sampleIndex + i] = signal.round();
      }
    }
  }

  await _createWavFile(file, samples, sampleRate);
}
```

**Test Group: BPM Range Detection** (add inside `main()`, after existing groups):
```dart
group('BPM Range Detection', () {
  for (final bpm in [40, 60, 80, 100, 120, 140, 160, 180, 200]) {
    test('Should detect >= 80% of beats at $bpm BPM', () async {
      final testFile = File('${tempDir.path}/bpm_$bpm.wav');
      const durationSeconds = 10;
      await _createTestWavWithBeats(testFile,
        sampleRate: 44100, bpm: bpm, durationSeconds: durationSeconds);

      final analyzer = RhythmAnalyzer();
      final tapEvents = await analyzer.analyzeAudio(
        audioFilePath: testFile.path,
        bpm: bpm,
        durationSeconds: durationSeconds,
        checkBleed: false,
      );

      final expectedBeats = (durationSeconds * bpm / 60).floor();
      final detectionRate = tapEvents.length / expectedBeats;

      print('BPM $bpm: detected ${tapEvents.length}/$expectedBeats beats (${(detectionRate * 100).toStringAsFixed(1)}%)');

      expect(detectionRate, greaterThanOrEqualTo(0.8),
          reason: 'Should detect >= 80% of beats at $bpm BPM');

      // No double-detection: detected count should not exceed 1.2x expected
      expect(tapEvents.length, lessThanOrEqualTo((expectedBeats * 1.2).ceil()),
          reason: 'Should not detect more than 120% of expected beats (double-detection) at $bpm BPM');
    });
  }
});
```

**Test Group: Amplitude Range Detection** (add after BPM Range):
```dart
group('Amplitude Range Detection', () {
  for (final entry in [
    {'amplitude': 0.1, 'label': 'very soft'},
    {'amplitude': 0.3, 'label': 'soft'},
    {'amplitude': 0.5, 'label': 'medium'},
    {'amplitude': 0.8, 'label': 'loud'},
    {'amplitude': 1.0, 'label': 'maximum'},
  ]) {
    final amplitude = entry['amplitude'] as double;
    final label = entry['label'] as String;

    test('Should detect >= 80% of beats at $label amplitude ($amplitude)', () async {
      final testFile = File('${tempDir.path}/amp_${label.replaceAll(' ', '_')}.wav');
      const bpm = 120;
      const durationSeconds = 5;
      await _createTestWavWithBeats(testFile,
        sampleRate: 44100, bpm: bpm, durationSeconds: durationSeconds,
        amplitude: amplitude);

      final analyzer = RhythmAnalyzer();
      final tapEvents = await analyzer.analyzeAudio(
        audioFilePath: testFile.path,
        bpm: bpm,
        durationSeconds: durationSeconds,
        checkBleed: false,
      );

      final expectedBeats = (durationSeconds * bpm / 60).floor();
      final detectionRate = tapEvents.length / expectedBeats;

      print('Amplitude $amplitude ($label): detected ${tapEvents.length}/$expectedBeats beats (${(detectionRate * 100).toStringAsFixed(1)}%)');

      expect(detectionRate, greaterThanOrEqualTo(0.8),
          reason: 'Should detect >= 80% of $label taps (amplitude $amplitude)');
    });
  }
});
```

**Test Group: Timing Accuracy** (add after Amplitude Range):
```dart
group('Timing Accuracy', () {
  test('Average timing error should be < 50ms for on-beat synthetic impulses at 120 BPM', () async {
    final testFile = File('${tempDir.path}/timing_accuracy.wav');
    const bpm = 120;
    const durationSeconds = 10;
    await _createTestWavWithBeats(testFile,
      sampleRate: 44100, bpm: bpm, durationSeconds: durationSeconds);

    final analyzer = RhythmAnalyzer();
    final tapEvents = await analyzer.analyzeAudio(
      audioFilePath: testFile.path,
      bpm: bpm,
      durationSeconds: durationSeconds,
      checkBleed: false,
    );

    expect(tapEvents.length, greaterThan(5),
        reason: 'Need enough beats to measure timing accuracy');

    final avgError = RhythmAnalyzer.calculateAverageError(tapEvents);
    print('Timing accuracy at 120 BPM: avg error = ${avgError.toStringAsFixed(1)}ms over ${tapEvents.length} beats');

    expect(avgError, lessThan(50),
        reason: 'Average timing error should be < 50ms for perfectly-timed synthetic impulses');
  });

  test('Average timing error should be < 50ms at 60 BPM (slow tempo)', () async {
    final testFile = File('${tempDir.path}/timing_60bpm.wav');
    const bpm = 60;
    const durationSeconds = 10;
    await _createTestWavWithBeats(testFile,
      sampleRate: 44100, bpm: bpm, durationSeconds: durationSeconds);

    final analyzer = RhythmAnalyzer();
    final tapEvents = await analyzer.analyzeAudio(
      audioFilePath: testFile.path,
      bpm: bpm,
      durationSeconds: durationSeconds,
      checkBleed: false,
    );

    expect(tapEvents.length, greaterThan(3),
        reason: 'Need enough beats to measure timing accuracy');

    final avgError = RhythmAnalyzer.calculateAverageError(tapEvents);
    print('Timing accuracy at 60 BPM: avg error = ${avgError.toStringAsFixed(1)}ms over ${tapEvents.length} beats');

    expect(avgError, lessThan(50),
        reason: 'Average timing error should be < 50ms for perfectly-timed synthetic impulses');
  });

  test('Average timing error should be < 50ms at 200 BPM (fast tempo)', () async {
    final testFile = File('${tempDir.path}/timing_200bpm.wav');
    const bpm = 200;
    const durationSeconds = 10;
    await _createTestWavWithBeats(testFile,
      sampleRate: 44100, bpm: bpm, durationSeconds: durationSeconds);

    final analyzer = RhythmAnalyzer();
    final tapEvents = await analyzer.analyzeAudio(
      audioFilePath: testFile.path,
      bpm: bpm,
      durationSeconds: durationSeconds,
      checkBleed: false,
    );

    expect(tapEvents.length, greaterThan(10),
        reason: 'Need enough beats to measure timing accuracy');

    final avgError = RhythmAnalyzer.calculateAverageError(tapEvents);
    print('Timing accuracy at 200 BPM: avg error = ${avgError.toStringAsFixed(1)}ms over ${tapEvents.length} beats');

    expect(avgError, lessThan(50),
        reason: 'Average timing error should be < 50ms for perfectly-timed synthetic impulses');
  });
});
```

**Important notes:**
- Use `checkBleed: false` in all new tests (synthetic impulses are perfectly timed and would trigger bleed detection).
- Use `durationSeconds: 10` for BPM range tests to get enough beats even at 40 BPM (should get ~6-7 beats).
- The `_createTestWavWithBeats` helper uses broadband impulse with decay envelope (not pure sine) -- more realistic than existing tests.
- All test groups must be INSIDE the outer `group('RhythmAnalyzer Unit Tests', ...)` so they share the `setUp`/`tearDown` for `tempDir`.
  </action>
  <verify>
Run the full test suite:
```bash
cd ai_rhythm_coach && flutter test test/services/rhythm_analyzer_test.dart
```
All tests should pass, including all 9 BPM range tests, all 5 amplitude range tests, and all 3 timing accuracy tests (total ~26 tests).

Print output will show detection rates for each BPM and amplitude level.
  </verify>
  <done>
All BPM range tests pass (>= 80% detection at 40, 60, 80, 100, 120, 140, 160, 180, 200 BPM). All amplitude range tests pass (>= 80% detection for very soft through maximum amplitude). All timing accuracy tests pass (< 50ms average error). No double-detection at any BPM (detected <= 1.2x expected). The test suite provides comprehensive proof that Phase 2 success criteria are met for synthetic data.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify onset detection accuracy across BPM and amplitude ranges</name>
  <files>ai_rhythm_coach/test/services/rhythm_analyzer_test.dart</files>
  <action>
Human reviews the test output from the comprehensive test suite to confirm the onset detection algorithm meets Phase 2 success criteria. The test output will show detection rates for each BPM (40-200) and each amplitude level (very soft through maximum).

What was built: Complete onset detection algorithm with adaptive thresholding, tested across BPM range 40-200 and amplitude range soft-to-loud. All synthetic tests pass.

How to verify:
1. Review the test output from `flutter test test/services/rhythm_analyzer_test.dart` to confirm detection rates across BPM and amplitude ranges
2. Optionally test on physical device: build debug APK (`flutter build apk --debug` from `ai_rhythm_coach/`), install on device, record a practice session, and check that onsets are detected from the recording
3. Note: Real-device testing with actual microphone recordings is where the algorithm will face its true test. Synthetic tests establish baseline correctness but real recordings have noise, room reflections, and varying microphone sensitivity. Parameter tuning (gamma, delta) may need adjustment based on real-world results.
  </action>
  <verify>User types "approved" or describes issues with detection accuracy.</verify>
  <done>User has reviewed test output and approved the onset detection implementation for Phase 2.</done>
</task>

</tasks>

<verification>
1. `flutter test test/services/rhythm_analyzer_test.dart` -- All tests pass (~26 total)
2. `flutter test test/rhythm_analyzer_latency_test.dart` -- Latency tests still pass
3. `flutter test test/services/rhythm_analyzer_diagnostic_test.dart` -- Diagnostic tests still pass
4. BPM range: >= 80% detection rate at every BPM in [40, 60, 80, 100, 120, 140, 160, 180, 200]
5. Amplitude range: >= 80% detection rate at amplitudes [0.1, 0.3, 0.5, 0.8, 1.0]
6. Timing: < 50ms average error at 60, 120, and 200 BPM
7. No double-detection: detected count <= 1.2x expected at all BPMs
</verification>

<success_criteria>
- All existing and new tests pass
- Detection works across 40-200 BPM (>= 80% rate)
- Detection works across soft-to-loud amplitudes (>= 80% rate)
- Timing accuracy < 50ms for synthetic data
- No double-detection at any BPM
- User has reviewed test output and approved
</success_criteria>

<output>
After completion, create `.planning/phases/02-onset-detection/02-02-SUMMARY.md`
</output>
